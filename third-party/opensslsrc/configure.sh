#!/bin/bash

export LC_COLLATE=C

###
# Welcome to the upgrade.
#
# We do some wacky things like replace CC for the make command and awk
# to parse apart the output.

readonly ME="$0"
readonly EXECNAME=$(basename "$0")
readonly CWD=$(dirname "$(readlink -f "$ME" 2> /dev/null || greadlink -f "$ME")")
readonly TMPDIR=${TMPDIR:-/tmp}
readonly WORKDIR=$(mktemp -d "$TMPDIR/$EXECNAME.XXXXXXX")

###
# Options and configurations
#
# ./configure.sh <[ios]|android|osx>
#
readonly VERSION=$([[ -f "$CWD/.version" ]] && cat "$CWD/.version" || echo 1.0.2)
readonly SOURCE_DIR=${SOURCE_DIR:-openssl-$VERSION}
readonly INCLUDE_DIR=include/openssl
readonly BUILD_DIR="$CWD/$SOURCE_DIR"

###
# That one weird trick
#
# This overrides `CC` for the Makefile to print out which files are
# touched and when compiling OpenSSL.  We do this to generate DEFS, a
# file that provides BUCK a list of sources.
#
readonly CC="@echo \$(subst $CWD/$SOURCE_DIR,openssl-$VERSION,\$(PWD)) \$ CC"

function log
{
    echo >&2 "$EXECNAME: $*"
}

function die
{
    log "$@"
    exit 1
}

function usage
{
    log "$0"
    exit 0
}

function cleanup {
    if [[ -n "$KEEP_WORKDIR" ]] ; then
        log "keeping work directory $WORKDIR"
    else
        rm -fr "$WORKDIR"
    fi
}


function make_defs
{
    echo "# DO NOT EDIT. Generated by $ME"
    echo "OPENSSL_VERSION = '$VERSION'"
    echo "OPENSSL_SOURCE = 'openssl-$VERSION'"
}

function make_headers
{
    mkdir -p "$BUILD_DIR/$INCLUDE_DIR"
    (
        cd "$BUILD_DIR/$INCLUDE_DIR" || die "Could not change dir into $BUILD_DIR/$INCLUDE_DIR"
        find ../../crypto -name Makefile -type f | while read -r f; do
            grep 'include/openssl' "$BUILD_DIR/$INCLUDE_DIR/$f" | awk -F' ' '{
  for (i = 1; i <= NF; i++) {
    if ($i ~ /\.\.\/include\/openssl\/[a-z0-9_]*\.h/) {
      print $i
    }
  }
}' | sort -u | xargs -n1 ln -s -f
        done
    )
}

function configure
{
    local TARGET="$1"
    local BUILD_TARGET="$2"
    local CONFIG_DIR=config.$TARGET

    log "Running $TARGET configure..."
    ./Client-Configure "$BUILD_TARGET" > /dev/null
    make clean > /dev/null
    ## Fix up headers
    log "Fix up config header..."
    (
        mkdir -p "$CONFIG_DIR"
        mv crypto/opensslconf.h "$CONFIG_DIR"
        cd $INCLUDE_DIR/ && ln -s -f ../../"$CONFIG_DIR"/opensslconf.h
    )

    log "[$TARGET] Generating headermap..."
    generate_headermap | sort -u > "$WORKDIR/headermap.$TARGET"
    log "[$TARGET] Extracting source for libcryto..."
    extract_sources build_crypto | sort -u > "$WORKDIR/crypto.$TARGET"
    log "[$TARGET] Extracting source for libssl..."
    extract_sources build_ssl | sort -u > "$WORKDIR/ssl.$TARGET"
    log "[$TARGET] Extracting flags..."
    extract_flags | sort -u > "$WORKDIR/flags.$TARGET"
    ## Fix up built headers
    log "[$TARGET] Fixing up buildinf.h..."
    mv crypto/buildinf.h "$CONFIG_DIR"
    log "Done configuring $TARGET"
}

function generate_headermap
{
    ## Generate Header Map
    for header in "$INCLUDE_DIR"/*.h; do
        header=$(basename "$header")
        ## Clean up header
        if [[ ! -f "$INCLUDE_DIR"/$(readlink "$INCLUDE_DIR/$header") ]]; then
            (
                cd "$INCLUDE_DIR" || die "Could not change dir into $INCLUDE_DIR"
                ln -s -f "$(find ../.. -name "$header" -type f)"
            )
        fi
        path=$(readlink "$INCLUDE_DIR/$header" | cut -d '/' -f 3-9 | tr -s '/')
        echo "  'openssl/$header' : '$SOURCE_DIR/$path',"
    done
}

function extract_sources
{
    MAKE_TARGET=$1
    make "$MAKE_TARGET" CC="$CC" AR="@true" 2> /dev/null | \
        grep 'CC' | \
        awk -v srcs="$SRCS" '{
  if ($NF ~ "\\.c") {
    print "  '\''" $1"/"$NF "'\'',";
  }
}'
}

function extract_flags
{
    make build_crypto CC="@echo CC" AR="@false" 2> /dev/null | \
        grep 'CC' | \
        awk 'BEGIN { len = 0; } {
  for (i = 1; i < NF; i ++) {
    if ($i ~ "^-D" || $i ~ "^-f") {
      flags[len++] = $i;
    }
  }
} END {
  for (i = 0; i < len; i++) {
    if (!printed[flags[i]]) {
      print "  '\''" flags[i] "'\'',";
    }
    printed[flags[i]] = 1;
  }
}'
}

function merge_files
{
    HEADER="$1"
    TRAILER="$2"
    BASE_FILE="$3"
    combined="$(comm -12 "$WORKDIR/$BASE_FILE.ios" "$WORKDIR/$BASE_FILE.android")"
    if [[ -n "$combined" ]]; then
        echo
        echo "$HEADER"
        echo "$combined"
        echo "$TRAILER"
    fi

    android="$(comm -13 "$WORKDIR/$BASE_FILE.ios" "$WORKDIR/$BASE_FILE.android")"
    if [[ -n "$android" ]]; then
        echo
        echo "ANDROID_$HEADER"
        echo "$android"
        echo "$TRAILER"
    fi

    ios="$(comm -23 "$WORKDIR/$BASE_FILE.ios" "$WORKDIR/$BASE_FILE.android")"
    if [[ -n "$ios" ]]; then
        echo
        echo "IOS_$HEADER"
        echo "$ios"
        echo "$TRAILER"
    fi
}

trap cleanup EXIT
set -o pipefail

while getopts 'h' OPTNAME ; do
    case "$OPTNAME" in
        h|?) usage ;;
    esac
done

## Run make to extract the source files

cd "$BUILD_DIR" || fail "Could not change dir to $BUILD_DIR"

## We need to force header generation and clean up after ourselves
log "Setting up header symlinks..."
make_headers

configure ios iphoneos-cross
configure android android-armv7

{
    ## Start creating the DEFS file
    make_defs

    # Merging headers and sources
    merge_files "OPENSSL_HEADERS = {" "}" headermap
    merge_files "LIBCRYPTO_SRCS = [" "]" crypto
    merge_files "LIBSSL_SRCS = [" "]" ssl
    merge_files "OPENSSL_CFLAGS = [" "]" flags
} > "$CWD/DEFS"

rm -rf "${BUILD_DIR:?}/$INCLUDE_DIR"
log "Done"
